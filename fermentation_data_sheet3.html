<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <script>
if (!sessionStorage.getItem('isLogin')) {
    window.location.href = 'index.html';
}
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤ç››ç”Ÿäº§æ•°æ®å¯è§†åŒ–åˆ†æç³»ç»Ÿ - ä¸‰çº§æ•°æ®</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§¬</text></svg>">
    <!-- æ·»åŠ SheetJSåº“ç”¨äºExcelæ–‡ä»¶è§£æ -->
    <script src="https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script>
        // Chart.jså’Œæ’ä»¶å¤šé‡åŠ è½½ç­–ç•¥
        window.chartJsLoaded = false;
        window.chartJsLoadFailed = false;
        window.zoomPluginLoaded = false;
        
        // Chart.js CDNåˆ—è¡¨ï¼ˆæŒ‰å¯é æ€§æ’åºï¼‰
        const chartCdnList = [
            'https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js',
            'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js',
            'https://cdn.bootcdn.net/ajax/libs/Chart.js/4.4.1/chart.umd.min.js',
            'https://lib.baomitu.com/Chart.js/4.4.1/chart.umd.min.js',
            'https://unpkg.com/chart.js@4.4.1/dist/chart.umd.min.js'
        ];
        
        // Zoomæ’ä»¶CDNåˆ—è¡¨
        const zoomCdnList = [
            'https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js',
            'https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.0.1/chartjs-plugin-zoom.min.js',
            'https://unpkg.com/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js'
        ];
        
        let currentChartCdnIndex = 0;
        let currentZoomCdnIndex = 0;
        
        function updateLoadingStatus(message, details = '') {
            const loadingText = document.getElementById('loadingText');
            const loadingDetails = document.getElementById('loadingDetails');
            if (loadingText) loadingText.textContent = message;
            if (loadingDetails) loadingDetails.textContent = details;
        }
        
        function retryChartLoad() {
            console.log('ç”¨æˆ·ç‚¹å‡»é‡è¯•ï¼Œé‡æ–°å¼€å§‹åŠ è½½è¿‡ç¨‹');
            window.chartJsLoaded = false;
            window.chartJsLoadFailed = false;
            window.zoomPluginLoaded = false;
            currentChartCdnIndex = 0;
            currentZoomCdnIndex = 0;
            
            // éšè—é‡è¯•æŒ‰é’®ï¼Œæ˜¾ç¤ºåŠ è½½çŠ¶æ€
            const retryButton = document.getElementById('retryButton');
            if (retryButton) retryButton.style.display = 'none';
            
            const loadingIndicator = document.getElementById('loadingIndicator');
            if (loadingIndicator) loadingIndicator.style.display = 'block';
            
            updateLoadingStatus('æ­£åœ¨é‡æ–°åŠ è½½å›¾è¡¨ç»„ä»¶...', 'é‡æ–°å°è¯•ä»CDNåŠ è½½Chart.jsåº“');
            
            // ç§»é™¤å¯èƒ½å­˜åœ¨çš„é”™è¯¯ä¿¡æ¯
            const existingError = document.querySelector('.error');
            if (existingError) existingError.remove();
            
            loadChartJS();
        }
        
        function loadChartJS() {
            if (currentChartCdnIndex >= chartCdnList.length) {
                console.log('æ‰€æœ‰Chart.js CDNéƒ½åŠ è½½å¤±è´¥ï¼Œæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯');
                window.chartJsLoadFailed = true;
                updateLoadingStatus('å›¾è¡¨åº“åŠ è½½å¤±è´¥', 'æ‰€æœ‰CDNæºéƒ½æ— æ³•è®¿é—®');
                document.getElementById('retryButton').style.display = 'inline-block';
                return;
            }
            
            const cdnName = chartCdnList[currentChartCdnIndex].split('/')[2]; // æå–åŸŸå
            updateLoadingStatus(
                `æ­£åœ¨åŠ è½½å›¾è¡¨ç»„ä»¶... (${currentChartCdnIndex + 1}/${chartCdnList.length})`,
                `å°è¯•ä» ${cdnName} åŠ è½½Chart.jsåº“`
            );
            
            const script = document.createElement('script');
            script.src = chartCdnList[currentChartCdnIndex];
            script.timeout = 5000; // 5ç§’è¶…æ—¶
            
            script.onload = () => {
                console.log(`Chart.jsä»CDN ${currentChartCdnIndex + 1}åŠ è½½æˆåŠŸ: ${chartCdnList[currentChartCdnIndex]}`);
                window.chartJsLoaded = true;
                updateLoadingStatus('Chart.jsåº“åŠ è½½æˆåŠŸï¼Œæ­£åœ¨åŠ è½½ç¼©æ”¾æ’ä»¶...', `å¼€å§‹åŠ è½½zoomæ’ä»¶`);
                loadZoomPlugin(); // åŠ è½½zoomæ’ä»¶
            };
            
            script.onerror = () => {
                console.log(`Chart.js CDN ${currentChartCdnIndex + 1}åŠ è½½å¤±è´¥: ${chartCdnList[currentChartCdnIndex]}`);
                currentChartCdnIndex++;
                setTimeout(loadChartJS, 1000); // 1ç§’åå°è¯•ä¸‹ä¸€ä¸ªCDN
            };
            
            // è¶…æ—¶å¤„ç†
            setTimeout(() => {
                if (!window.chartJsLoaded && currentChartCdnIndex === chartCdnList.indexOf(script.src)) {
                    console.log(`Chart.js CDN ${currentChartCdnIndex + 1}åŠ è½½è¶…æ—¶`);
                    script.onerror();
                }
            }, 5000);
            
            document.head.appendChild(script);
        }
        
        function loadZoomPlugin() {
            if (currentZoomCdnIndex >= zoomCdnList.length) {
                console.log('æ‰€æœ‰Zoomæ’ä»¶CDNéƒ½åŠ è½½å¤±è´¥ï¼Œç»§ç»­ä½†ä¸å¯ç”¨ç¼©æ”¾åŠŸèƒ½');
                window.zoomPluginLoaded = false;
                updateLoadingStatus('ç¼©æ”¾æ’ä»¶åŠ è½½å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨åŸºç¡€åŠŸèƒ½', 'å›¾è¡¨åŠŸèƒ½å¯ç”¨ï¼Œä½†ç¼©æ”¾åŠŸèƒ½ä¸å¯ç”¨');
                return;
            }
            
            const cdnName = zoomCdnList[currentZoomCdnIndex].split('/')[2]; // æå–åŸŸå
            updateLoadingStatus(
                `æ­£åœ¨åŠ è½½ç¼©æ”¾æ’ä»¶... (${currentZoomCdnIndex + 1}/${zoomCdnList.length})`,
                `å°è¯•ä» ${cdnName} åŠ è½½zoomæ’ä»¶`
            );
            
            const script = document.createElement('script');
            script.src = zoomCdnList[currentZoomCdnIndex];
            script.timeout = 5000; // 5ç§’è¶…æ—¶
            
            script.onload = () => {
                console.log(`Zoomæ’ä»¶ä»CDN ${currentZoomCdnIndex + 1}åŠ è½½æˆåŠŸ: ${zoomCdnList[currentZoomCdnIndex]}`);
                window.zoomPluginLoaded = true;
                
                // æ³¨å†Œzoomæ’ä»¶åˆ°Chart.js
                console.log('å°è¯•æ³¨å†Œzoomæ’ä»¶...');
                
                // å°è¯•å¤šç§æ³¨å†Œæ–¹å¼
                let registered = false;
                
                if (typeof Chart !== 'undefined' && Chart.register) {
                    // æ–¹å¼1ï¼šä½¿ç”¨window.ChartZoom
                    if (window.ChartZoom) {
                        Chart.register(window.ChartZoom);
                        registered = true;
                        console.log('æ–¹å¼1ï¼šä½¿ç”¨window.ChartZoomæ³¨å†ŒæˆåŠŸ');
                    }
                    // æ–¹å¼2ï¼šæ£€æŸ¥æ˜¯å¦è‡ªåŠ¨æ³¨å†Œ
                    else if (Chart.Zoom) {
                        console.log('æ–¹å¼2ï¼šæ’ä»¶å·²è‡ªåŠ¨æ³¨å†Œ');
                        registered = true;
                    }
                    // æ–¹å¼3ï¼šæ£€æŸ¥å…¨å±€å˜é‡
                    else if (window.chartjsPluginZoom) {
                        Chart.register(window.chartjsPluginZoom);
                        registered = true;
                        console.log('æ–¹å¼3ï¼šä½¿ç”¨window.chartjsPluginZoomæ³¨å†ŒæˆåŠŸ');
                    }
                }
                
                if (registered) {
                    console.log('Zoomæ’ä»¶æ³¨å†ŒæˆåŠŸ');
                    updateLoadingStatus('æ‰€æœ‰ç»„ä»¶åŠ è½½æˆåŠŸ', 'Chart.jså’Œç¼©æ”¾æ’ä»¶éƒ½å·²å°±ç»ª');
                } else {
                    console.log('Zoomæ’ä»¶æ³¨å†Œå¤±è´¥ï¼Œå°è¯•ç›´æ¥ä½¿ç”¨');
                    // å³ä½¿æ³¨å†Œå¤±è´¥ï¼Œä¹Ÿå°è¯•ä½¿ç”¨zoomåŠŸèƒ½
                    window.zoomPluginLoaded = true; // ä¿æŒä¸ºtrueï¼Œå°è¯•ä½¿ç”¨
                    updateLoadingStatus('ç¼©æ”¾æ’ä»¶æ³¨å†Œæœ‰é—®é¢˜ï¼Œä½†å°è¯•ç»§ç»­ä½¿ç”¨', 'ç¼©æ”¾åŠŸèƒ½å¯èƒ½ä¸å¯ç”¨');
                }
            };
            
            script.onerror = () => {
                console.log(`Zoomæ’ä»¶CDN ${currentZoomCdnIndex + 1}åŠ è½½å¤±è´¥: ${zoomCdnList[currentZoomCdnIndex]}`);
                currentZoomCdnIndex++;
                setTimeout(loadZoomPlugin, 1000); // 1ç§’åå°è¯•ä¸‹ä¸€ä¸ªCDN
            };
            
            // è¶…æ—¶å¤„ç†
            setTimeout(() => {
                if (!window.zoomPluginLoaded && currentZoomCdnIndex === zoomCdnList.indexOf(script.src)) {
                    console.log(`Zoomæ’ä»¶CDN ${currentZoomCdnIndex + 1}åŠ è½½è¶…æ—¶`);
                    script.onerror();
                }
            }, 5000);
            
            document.head.appendChild(script);
        }
        
        // å¼€å§‹åŠ è½½
        loadChartJS();
        
        // é¢å¤–çš„è¶…æ—¶ä¿æŠ¤
        setTimeout(() => {
            if (!window.chartJsLoaded && typeof Chart === 'undefined') {
                console.log('Chart.jsæœ€ç»ˆè¶…æ—¶ï¼Œæ ‡è®°ä¸ºåŠ è½½å¤±è´¥');
                window.chartJsLoadFailed = true;
            } else if (window.chartJsLoaded && window.zoomPluginLoaded === undefined) {
                console.log('zoomæ’ä»¶åŠ è½½è¶…æ—¶ï¼Œä½†Chart.jså¯ç”¨');
                window.zoomPluginLoaded = false;
            }
        }, 25000); // 25ç§’æ€»è¶…æ—¶ï¼Œè€ƒè™‘zoomæ’ä»¶åŠ è½½æ—¶é—´
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Times New Roman", "æ¥·ä½“", KaiTi, serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        /* å¼ºåˆ¶è®¾ç½®æ‰€æœ‰å…ƒç´ çš„å­—ä½“å’ŒåŠ ç²— */
        * {
            font-family: "Times New Roman", "æ¥·ä½“", KaiTi, serif !important;
            font-weight: bold !important;
        }
        
        /* ç¡®ä¿æ•°æ®æ˜¾ç¤ºé¢æ¿çš„å­—ä½“å’ŒåŠ ç²— */
        .hover-data-name, .hover-data-type, .hover-data-value {
            font-family: "Times New Roman", "æ¥·ä½“", KaiTi, serif !important;
            font-weight: bold !important;
        }
        
        /* ç¡®ä¿æ‰€æœ‰æ–‡æœ¬å…ƒç´ çš„å­—ä½“å’ŒåŠ ç²— */
        h1, h2, h3, h4, h5, h6, p, span, div, label, button, input, textarea, select, 
        strong, b, em, i, small, code, pre, blockquote, cite, time, table, th, td, 
        caption, figcaption, mark, del, ins, sub, sup, abbr, dfn, address {
            font-family: "Times New Roman", "æ¥·ä½“", KaiTi, serif !important;
            font-weight: bold !important;
        }
        
        /* ç‰¹åˆ«é’ˆå¯¹å¯èƒ½å­˜åœ¨çš„æ™®é€šå­—ä½“çš„å…ƒç´  */
        .normal, .regular, .light, .thin {
            font-weight: bold !important;
        }
        
        /* ç¡®ä¿æ‰€æœ‰å¯èƒ½åŒ…å«æ–‡æœ¬çš„å…ƒç´ éƒ½åŠ ç²— */
        body, body *, canvas, svg, text {
            font-weight: bold !important;
        }

        .container {
            max-width: 99vw;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 3.0rem;
            margin-bottom: 10px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        .header p {
            font-size: 1.32rem;
            font-weight: bold;
            opacity: 1;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        .upload-section {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .upload-area {
            border: 3px dashed #007bff;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            background: white;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #0056b3;
            background: #f8f9ff;
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: #28a745;
            background: #f8fff8;
        }

        .upload-icon {
            font-size: 3.6rem;
            color: #007bff;
            margin-bottom: 25px;
            margin-top: -20px;
        }

        .upload-text {
            font-size: 1.56rem;
            color: #28a745;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .upload-hint {
            color: #28a745;
            font-size: 1.2rem;
            font-weight: bold;
        }

        #fileInput {
            display: none;
        }

        .file-info {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 30px;
            box-shadow: 0 10px 30px rgba(40, 167, 69, 0.3);
            display: none;
        }

        .controls {
            padding: 20px 30px;
            background: white;
            border-bottom: 1px solid #e9ecef;
            display: none;
            margin: 20px 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-item label {
            font-weight: bold;
            color: #495057;
            white-space: nowrap;
            font-size: 1.2rem;
        }

        .control-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #007bff;
        }

        .charts-container {
            padding: 30px;
            padding-bottom: 60px;
            display: none;
        }

        .batch-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .batch-info h3 {
            margin-bottom: 15px;
            font-size: 1.56rem;
        }

        .batch-details {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 0 15px;
        }

        .batch-detail {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 60px;
            flex: 0 1 auto;
            min-width: 120px;
        }

        .chart-wrapper {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 60px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            border: 1px solid #e9ecef;
        }

        .chart-title {
            font-size: 1.56rem;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid #f8f9fa;
        }

        .chart-container {
            position: relative;
            height: 600px;
            margin-bottom: 20px;
        }

        .hover-instruction {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            padding: 40px 20px;
            font-size: 1.32rem;
        }

        .hover-time-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .hover-time {
            font-size: 1.32rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .hover-duration {
            font-size: 1.32rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .hover-data-items {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .hover-data-item {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px 15px;
            border-left: 4px solid #b3c7f7;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            height: 120px;
            position: relative;
        }

        .hover-data-item.enabled {
            background: #fff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        .hover-data-name {
            font-size: 1.56rem;
            margin-bottom: 3px;
            font-weight: bold;
        }

        .hover-data-type {
            font-size: 1.2rem;
            margin-bottom: 3px;
            opacity: 0.8;
            font-weight: bold;
        }

        .hover-data-value {
            font-size: 1.56rem;
            font-weight: bold;
            font-family: "Times New Roman", "æ¥·ä½“", KaiTi, serif !important;
        }

        .hover-data-item.disabled {
            opacity: 1.0;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #6c757d;
            font-size: 1.32rem;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin: 20px;
            border-left: 4px solid #dc3545;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 15px;
            }
            
            .header h1 {
                font-size: 2.4rem;
            }
            
            .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .chart-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ§¬ å¤ç››ç”Ÿäº§æ•°æ®å¯è§†åŒ–åˆ†æç³»ç»Ÿ - ä¸‰çº§æ•°æ®</h1>
            <p>ä¸Šä¼ .xlsxæ ¼å¼çš„Excelæ–‡ä»¶ï¼ŒAIå¸®æ‚¨åˆ†æç¬¬ä¸‰ä¸ªå·¥ä½œè¡¨ï¼ˆä¸‰çº§ï¼‰çš„å…³é”®æŒ‡æ ‡ï¼</p>
        </div>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">ğŸ“</div>
                <div class="upload-text">æ‹–æ‹½æˆ–è€…ç‚¹å‡»é€‰æ‹©Excelæ–‡ä»¶åˆ°æ­¤å¤„</div>
                <div class="upload-hint">æ”¯æŒ.xlsxæ ¼å¼çš„Excelæ–‡ä»¶</div>
                <input type="file" id="fileInput" accept=".xlsx" />
            </div>
            <div class="file-info" id="fileInfo"></div>
            <div class="loading-indicator" id="loadingIndicator" style="display: block;">
                <div class="loading" id="loadingText">æ­£åœ¨åŠ è½½å›¾è¡¨ç»„ä»¶...</div>
                <div style="margin-top: 10px; font-size: 1.08rem; color: #6c757d;" id="loadingDetails">
                    æ­£åœ¨å°è¯•ä»CDNåŠ è½½Chart.jsåº“
                </div>
                <button onclick="retryChartLoad()" id="retryButton" 
                        style="display: none; margin-top: 10px; background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                    ğŸ”„ é‡æ–°å°è¯•
                </button>
            </div>
        </div>

        <div class="batch-info" id="batchInfo" style="margin: 20px 30px; display: none;"></div>

        <div class="controls" id="controls">
            <h3 style="margin-bottom: 15px; color: #2c3e50; font-size: 1.56rem; font-weight: 600; text-align: center;">ğŸ” è¯·å‹¾é€‰è¦å±•ç¤ºçš„æµ‹é‡å€¼</h3>
            <div class="control-group" id="parameterControls"></div>
            <div style="margin-top: 20px; margin-bottom: 0px; display: flex; gap: 36px; justify-content: center;">
                <button onclick="selectAllParameters()" style="background: linear-gradient(135deg, rgba(40, 167, 69, 0.8) 0%, rgba(32, 201, 151, 0.8) 100%); color: white; border: none; padding: 10px 20px; border-radius: 15px; cursor: pointer; font-weight: bold; font-size: 1.2rem; box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.32rem;"></span>
                    å‹¾é€‰å…¨éƒ¨æµ‹é‡å€¼
                </button>
                <button onclick="unselectAllParameters()" style="background: linear-gradient(135deg, rgba(253, 126, 20, 0.8) 0%, rgba(229, 90, 0, 0.8) 100%); color: white; border: none; padding: 10px 20px; border-radius: 15px; cursor: pointer; font-weight: bold; font-size: 1.2rem; box-shadow: 0 4px 15px rgba(253, 126, 20, 0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.32rem;"></span>
                    ä¸å‹¾é€‰ä»»ä½•æµ‹é‡å€¼
                </button>
            </div>
        </div>

        <div class="charts-container" id="chartsContainer">
            <div id="charts"></div>
        </div>
    </div>

    <script>
        // Excelæ–‡ä»¶å¤„ç†ç±»
        class ExcelDataViewer {
            constructor() {
                this.data = [];
                this.charts = {};
                // å®šä¹‰ä¸‰çº§æ•°æ®çš„å‚æ•°ï¼ŒåŸºäºExcelç¬¬ä¸‰ä¸ªsheetçš„åˆ—å
                this.parameters = [
                    { key: 'å‘é…µæ¸©åº¦/â„ƒ', label: 'å‘é…µæ¸©åº¦', color: '#FF6B35', enabled: true },
                    { key: 'å‹åŠ›/Mpa', label: 'å‹åŠ›', color: '#4ECDC4', enabled: false },
                    { key: 'ç©ºæ°”æµé‡/ï¼ˆmÂ³/hï¼‰', label: 'ç©ºæ°”æµé‡', color: '#45B7D1', enabled: false },
                    { key: 'åœ¨çº¿PH', label: 'åœ¨çº¿pH', color: '#96CEB4', enabled: false },
                    { key: 'DO/%', label: 'DOæº¶æ°§', color: '#26de81', enabled: false },
                    { key: 'è¡¥ç³–é€Ÿç‡/ï¼ˆL/hï¼‰', label: 'è¡¥ç³–é€Ÿç‡', color: '#fed330', enabled: false },
                    { key: 'è¡¥ç”˜æ²¹é€Ÿç‡/ï¼ˆL/hï¼‰', label: 'è¡¥ç”˜æ²¹é€Ÿç‡', color: '#fd9644', enabled: false },
                    { key: 'è¡¥æ°¨æ°´é€Ÿç‡/ï¼ˆL/hï¼‰', label: 'è¡¥æ°¨æ°´é€Ÿç‡', color: '#fc5c65', enabled: false },
                    { key: 'è¡¥ç”²é†‡é€Ÿç‡/ï¼ˆL/hï¼‰', label: 'è¡¥ç”²é†‡é€Ÿç‡', color: '#fd79a8', enabled: false },
                    { key: 'è¡¥æ°®æº/L', label: 'è¡¥æ°®æº', color: '#fdcb6e', enabled: false },
                    { key: 'ç¦»çº¿PH', label: 'ç¦»çº¿pH', color: '#74B9FF', enabled: false },
                    { key: 'ç”Ÿç‰©é‡', label: 'ç”Ÿç‰©é‡', color: '#A29BFE', enabled: false },
                    { key: 'é…¶æ´»/(U/ml)', label: 'é…¶æ´»', color: '#6c5ce7', enabled: false },
                    { key: 'æ°¨åŸºæ°®å«é‡mg/L', label: 'æ°¨åŸºæ°®å«é‡', color: '#a29bfe', enabled: false },
                    { key: 'è›‹ç™½å«é‡/(g/L)', label: 'è›‹ç™½å«é‡', color: '#ffeaa7', enabled: false },
                    { key: 'ç”²é†‡å«é‡/%', label: 'ç”²é†‡å«é‡', color: '#fab1a0', enabled: false },
                    { key: 'è¿˜åŸç³–å«é‡/%', label: 'è¿˜åŸç³–å«é‡', color: '#FD7272', enabled: false },
                    { key: 'è‘¡è„ç³–å«é‡/%', label: 'è‘¡è„ç³–å«é‡', color: '#00b894', enabled: false },
                    { key: 'è¡¥é…¸é€Ÿç‡/ï¼ˆL/hï¼‰', label: 'è¡¥é…¸é€Ÿç‡', color: '#e17055', enabled: false },
                    { key: 'è¡¥æ³¡æ•Œé€Ÿç‡/ï¼ˆL/hï¼‰', label: 'è¡¥æ³¡æ•Œé€Ÿç‡', color: '#81ecec', enabled: false },
                    { key: 'å‡ºæ–™è®°å½•', label: 'å‡ºæ–™è®°å½•', color: '#FF0000', enabled: false },
                    { key: 'å¤‡æ³¨', label: 'å¤‡æ³¨', color: '#9b59b6', enabled: false }
                ];
                
                this.initializeEventListeners();
                this.createParameterControls();
            }

            initializeEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');

                // æ–‡ä»¶ä¸Šä¼ äº‹ä»¶
                uploadArea.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e.target.files[0]));

                // æ‹–æ‹½ä¸Šä¼ 
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const file = e.dataTransfer.files[0];
                    if (file && file.name.endsWith('.xlsx')) {
                        this.handleFileSelect(file);
                    }
                });
            }

            createParameterControls() {
                const container = document.getElementById('parameterControls');
                
                this.parameters.forEach((param, index) => {
                    const controlItem = document.createElement('div');
                    controlItem.className = 'control-item';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `param_${index}`;
                    checkbox.checked = param.enabled;
                    checkbox.addEventListener('change', () => {
                        param.enabled = checkbox.checked;
                        this.updateCharts();
                    });
                    
                    const label = document.createElement('label');
                    label.htmlFor = `param_${index}`;
                    label.textContent = param.label;
                    label.style.color = param.color;
                    label.style.fontWeight = 'bold';
                    
                    controlItem.appendChild(checkbox);
                    controlItem.appendChild(label);
                    container.appendChild(controlItem);
                });
            }

            async handleFileSelect(file) {
                if (!file) return;

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const workbook = XLSX.read(arrayBuffer);
                    
                    // è·å–ç¬¬ä¸‰ä¸ªå·¥ä½œè¡¨ï¼ˆä¸‰çº§ï¼‰
                    if (workbook.SheetNames.length < 3) {
                        throw new Error('Excelæ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°ç¬¬ä¸‰ä¸ªå·¥ä½œè¡¨');
                    }
                    
                    const thirdSheetName = workbook.SheetNames[2];
                    const worksheet = workbook.Sheets[thirdSheetName];
                    
                    // è½¬æ¢ä¸ºJSONæ ¼å¼
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    
                    if (jsonData.length === 0) {
                        throw new Error('Excelæ–‡ä»¶ç¬¬ä¸‰ä¸ªå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆæ•°æ®');
                    }

                    // è§£æExcelæ•°æ®
                    const data = this.parseExcelData(jsonData);
                    
                    if (data.length === 0) {
                        throw new Error('ç¬¬ä¸‰ä¸ªå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„å‘é…µæ•°æ®');
                    }

                    this.data = data;
                    // é¢„å¤„ç†ç¨€ç–æ•°æ®ï¼Œä¸ºç¼ºå¤±ç‚¹ç”ŸæˆAIé¢„æµ‹å€¼
                    this.preprocessSparseData();
                    // è°ƒè¯•ï¼šæ£€æŸ¥é¢„å¤„ç†ç»“æœ
                    this.debugPreprocessingResults();
                    this.showBatchInfo(jsonData, file, data);
                    this.showControls();
                    this.createCharts();
                    
                } catch (error) {
                    this.showError(`æ–‡ä»¶è§£æå¤±è´¥: ${error.message}`);
                }
            }

            parseExcelData(jsonData) {
                try {
                    const data = [];
                    const descriptionInfo = [];
                    let hasContamination = false; // æ£€æŸ¥æ˜¯å¦æœ‰æŸ“èŒ
                    
                    // ç¬¬ä¸€è¡Œæ˜¯æ ‡é¢˜è¡Œ
                    const headers = jsonData[0];
                    console.log('Excelåˆ—æ ‡é¢˜:', headers);
                    
                    // æ‰¾åˆ°é•œæ£€åˆ—çš„ç´¢å¼•
                    const mirrorCheckIndex = headers.findIndex(header => header === 'é•œæ£€');
                    
                    // ä»ç¬¬äºŒè¡Œå¼€å§‹æ˜¯æ•°æ®
                    for (let i = 1; i < jsonData.length; i++) {
                        const row = jsonData[i];
                        if (!row || row.length === 0) continue;
                        
                        // æ”¶é›†ç¬¬ä¸€åˆ—çš„æ‰€æœ‰éç©ºå†…å®¹
                        if (row[0] && typeof row[0] === 'string' && row[0].trim() !== '') {
                            descriptionInfo.push(row[0].trim());
                        }
                        
                        // æ£€æŸ¥é•œæ£€åˆ—æ˜¯å¦æœ‰æŸ“èŒ
                        if (mirrorCheckIndex !== -1 && row[mirrorCheckIndex]) {
                            const mirrorValue = String(row[mirrorCheckIndex]).trim();
                            if (mirrorValue === 'æŸ“èŒ') {
                                hasContamination = true;
                            }
                        }
                        
                        // è·³è¿‡æè¿°è¡Œï¼ˆç¬¬ä¸€åˆ—åŒ…å«æè¿°ä¿¡æ¯çš„è¡Œï¼‰
                        if (row[0] && typeof row[0] === 'string' && 
                            (row[0].includes('ç½å·') || row[0].includes('æ‰¹å·') ||
                             row[0].includes('ä½“ç§¯') || row[0].includes('æ°¨æ°®') ||
                             row[0].includes('pH') || row[0].includes('ç´¯è®¡') ||
                             row[0].includes('å‡ºç½') || row[0].includes('æ£€æµ‹') ||
                             row[0].includes('æ¶ˆå‰') || row[0].includes('æ¶ˆå') ||
                             row[0].includes('å°æ–™') || row[0] === '')) {
                            continue;
                        }
                        
                        const record = {};
                        
                        // è§£ææ¯ä¸€åˆ—
                        headers.forEach((header, index) => {
                            const value = row[index];
                            if (header === 'æ—¥æœŸæ—¶é—´' && value) {
                                // å¤„ç†æ—¥æœŸæ—¶é—´
                                if (typeof value === 'number') {
                                    // Excelæ—¥æœŸæ•°å­—è½¬æ¢
                                    record['æ—¥æœŸæ—¶é—´'] = new Date((value - 25569) * 86400 * 1000);
                                } else {
                                    record['æ—¥æœŸæ—¶é—´'] = new Date(value);
                                }
                            } else if (header === 'å‘é…µå‘¨æœŸ/h') {
                                record['å‘é…µè®¡æ—¶'] = parseFloat(value) || 0;
                            } else if (header === 'å¤‡æ³¨') {
                                // å¤‡æ³¨å­—æ®µä¿æŒä¸ºå­—ç¬¦ä¸²ï¼Œä¸è½¬æ¢ä¸ºæ•°å­—
                                record[header] = (value !== undefined && value !== null) ? 
                                    String(value).trim() : '';
                            } else if (header) {
                                // ç¡®ä¿æ‰€æœ‰æ•°å€¼å­—æ®µéƒ½è¢«åˆå§‹åŒ–ï¼Œå³ä½¿ä¸ºç©ºä¹Ÿè®¾ä¸º0
                                record[header] = (value !== undefined && value !== null && value !== '') ? 
                                    (typeof value === 'number' ? value : parseFloat(value) || 0) : 0;
                            }
                        });
                        
                        // åªæ·»åŠ æœ‰æ—¥æœŸæ—¶é—´çš„è®°å½•
                        if (record['æ—¥æœŸæ—¶é—´'] && !isNaN(record['æ—¥æœŸæ—¶é—´'].getTime())) {
                            data.push(record);
                        }
                    }
                    
                    // ç¡®ä¿æ‰€æœ‰æ•°æ®å­—æ®µéƒ½æ˜¯æœ‰æ•ˆæ•°å€¼
                    data.forEach((record, index) => {
                        Object.keys(record).forEach(key => {
                            if (key !== 'æ—¥æœŸæ—¶é—´' && key !== 'å¤‡æ³¨' && typeof record[key] === 'number' && isNaN(record[key])) {
                                console.warn(`ç¬¬${index + 1}è¡Œçš„${key}å­—æ®µåŒ…å«NaNå€¼ï¼Œå·²è®¾ä¸º0`);
                                record[key] = 0;
                            }
                        });
                    });
                    
                    // å°†æè¿°ä¿¡æ¯å’ŒæŸ“èŒçŠ¶æ€å­˜å‚¨åˆ°æ•°æ®ä¸­ï¼Œä»¥ä¾¿åç»­ä½¿ç”¨
                    data.descriptionInfo = descriptionInfo;
                    data.hasContamination = hasContamination;
                    
                    return data.sort((a, b) => a['æ—¥æœŸæ—¶é—´'] - b['æ—¥æœŸæ—¶é—´']);
                } catch (error) {
                    throw new Error('Excelæ•°æ®è§£æå¤±è´¥: ' + error.message);
                }
            }

            showBatchInfo(jsonData, file, data) {
                const container = document.getElementById('batchInfo');
                container.style.display = 'block';
                
                // è®¡ç®—å‘é…µæ—¶é•¿
                const startTime = data[0]?.æ—¥æœŸæ—¶é—´;
                const endTime = data[data.length - 1]?.æ—¥æœŸæ—¶é—´;
                const duration = endTime && startTime ? 
                    Math.round((endTime - startTime) / (1000 * 60 * 60)) : 0;
                
                // è·å–åŠ¨æ€è¯»å–çš„ç¬¬ä¸€åˆ—ä¿¡æ¯
                const descriptionInfo = data.descriptionInfo || [];
                
                // ç”Ÿæˆç¬¬ä¸€åˆ—ä¿¡æ¯çš„HTML
                let descriptionHtml = '';
                if (descriptionInfo.length > 0) {
                    descriptionHtml = descriptionInfo.map(info => `
                        <div class="batch-detail">
                            <strong>${info}</strong>
                        </div>
                    `).join('');
                }
                
                // è·å–æŸ“èŒçŠ¶æ€
                const hasContamination = data.hasContamination || false;
                const contaminationStatus = hasContamination ? 'æŸ“èŒ' : 'æœªæŸ“èŒ';
                const contaminationColor = hasContamination ? 
                    'background: linear-gradient(135deg, rgba(220, 53, 69, 0.8) 0%, rgba(255, 102, 102, 0.8) 100%); color: white;' : 
                    'background: linear-gradient(135deg, rgba(40, 167, 69, 0.8) 0%, rgba(32, 201, 151, 0.8) 100%); color: white;';
                
                container.innerHTML = `
                    <h3 style="font-size: 1.56rem; text-align: center;">ğŸ§¬ å½“å‰ç”Ÿäº§æ‰¹æ¬¡æ•°æ®æ€»è§ˆï¼ˆä¸‰çº§ï¼‰</h3>
                    <div class="batch-details">
                        <div class="batch-detail">
                            <strong>æ–‡ä»¶åï¼š</strong> ${file.name}
                        </div>
                        <div class="batch-detail">
                            <strong>æ•°æ®ç‚¹æ•°ï¼š</strong> ${data.length}
                        </div>
                        <div class="batch-detail">
                            <strong>å‘é…µæ—¶é•¿ï¼š</strong> ${duration}å°æ—¶
                        </div>
                        <div class="batch-detail">
                            <strong>æ–‡ä»¶å¤§å°ï¼š</strong> ${(file.size / 1024).toFixed(1)} KB
                        </div>
                        ${descriptionHtml}
                        <div class="batch-detail" style="${contaminationColor} border-radius: 8px; padding: 10px 15px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); font-weight: bold; text-align: center;">
                            <strong>é•œæ£€çŠ¶æ€ï¼š${contaminationStatus}</strong>
                        </div>
                    </div>
                `;
            }

            showControls() {
                document.getElementById('controls').style.display = 'block';
            }

            createCharts() {
                const container = document.getElementById('chartsContainer');
                container.style.display = 'block';
                
                const chartsDiv = document.getElementById('charts');
                chartsDiv.innerHTML = '';

                // æ¸…ç†æ—§å›¾è¡¨
                Object.values(this.charts).forEach(chart => {
                    if (chart) chart.destroy();
                });
                this.charts = {};

                this.updateCharts();
            }

            updateCharts() {
                const chartsDiv = document.getElementById('charts');
                const enabledParams = this.parameters.filter(p => p.enabled);
                
                chartsDiv.innerHTML = '';

                this.createSingleChart(enabledParams, chartsDiv);
                this.createHoverDataPanel(chartsDiv);
            }

            createHoverDataPanel(container) {
                const wrapper = document.createElement('div');
                wrapper.className = 'chart-wrapper';
                wrapper.innerHTML = `
                    <div class="chart-title">ğŸ§¬ ä¸Šå›¾é¼ æ ‡æ‚¬åœå¤„ç”Ÿäº§æ•°æ®ç›‘æµ‹é¢æ¿</div>
                    <div class="hover-time-info">
                        <div class="hover-time">ğŸ“… æš‚æ— æ•°æ®</div>
                        <div class="hover-duration">å‘é…µç¬¬0.0å°æ—¶</div>
                    </div>
                    <div class="hover-data-grid" id="hoverDataGrid"></div>
                `;
                container.appendChild(wrapper);
            }

            createSingleChart(parameters, container) {
                const wrapper = document.createElement('div');
                wrapper.className = 'chart-wrapper';
                const zoomHint = window.zoomPluginLoaded ? 
                    'å°æç¤ºï¼šé¼ æ ‡æ»šè½®æ¨ªå‘ç¼©æ”¾æ—¶é—´è½´ï¼ŒåŒå‡»é¼ æ ‡å·¦é”®é‡ç½®ç¼©æ”¾' :
                    '';
                
                wrapper.innerHTML = `
                    <div class="chart-title">ğŸ§¬ ä¸‰çº§å‘é…µè¿‡ç¨‹å…³é”®æµ‹é‡å€¼æ—¶åºåˆ†æå›¾</div>
                    <div style="text-align: center; font-size: 1.2rem; margin-bottom: 20px; display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
                        <span style="color: #28a745; font-weight: bold;">âš« å®å¿ƒç‚¹ï¼šå®æµ‹å€¼</span>
                        <span style="color: #ff9800; font-weight: bold;">âšª ç©ºå¿ƒç‚¹ï¼šAIé¢„æµ‹å€¼ ğŸ¤–</span>
                        <span style="color: #FF0000; font-weight: bold;">ğŸ”´ å¤§çº¢ç‚¹ï¼šå‡ºæ–™è®°å½• ğŸ“¦</span>
                        <span style="color: #9b59b6; font-weight: bold;">ğŸŸ£ ç´«è‰²ç‚¹ï¼šå¤‡æ³¨ä¿¡æ¯ ğŸ“</span>
                    </div>
                    <div style="text-align: center; font-size: 1.2rem; color: #28a745; font-weight: bold; margin-bottom: 5px;">
                        ${zoomHint}
                    </div>
                    <div class="chart-container">
                        <canvas id="chart_main"></canvas>
                    </div>
                `;
                container.appendChild(wrapper);

                const canvas = wrapper.querySelector('canvas');
                const ctx = canvas.getContext('2d');

                // å¦‚æœæ²¡æœ‰å¯ç”¨çš„å‚æ•°ï¼Œæ˜¾ç¤ºç©ºå›¾è¡¨
                if (parameters.length === 0) {
                    const emptyChartPlugin = {
                        id: 'emptyChart',
                        afterDraw: function(chart) {
                            const ctx = chart.ctx;
                            const width = chart.width;
                            const height = chart.height;
                            
                            ctx.save();
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillStyle = '#28a745';
                            ctx.font = 'bold 19px "Times New Roman", "æ¥·ä½“", KaiTi, serif';
                            ctx.fillText('è¯·åœ¨ä¸Šæ–¹å‹¾é€‰è¦å±•ç¤ºçš„æµ‹é‡å€¼', width / 2, height / 2 - 10);
                            ctx.font = 'bold 19px "Times New Roman", "æ¥·ä½“", KaiTi, serif';
                            ctx.fillText('å‹¾é€‰ååœ¨æ­¤å¤„å°†å±•ç¤ºç›¸åº”æµ‹é‡å€¼çš„æ—¶åºåˆ†æå›¾', width / 2, height / 2 + 20);
                            ctx.restore();
                        }
                    };

                    const chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: []
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: { enabled: false }
                            },
                            scales: {
                                x: {
                                    title: { 
                                        display: true, 
                                        text: 'æ—¶é—´',
                                        font: { size: 19, weight: 'bold', family: '"Times New Roman", "æ¥·ä½“", KaiTi, serif' }
                                    }
                                },
                                y: {
                                    title: { 
                                        display: true, 
                                        text: 'æµ‹é‡å€¼',
                                        font: { size: 19, weight: 'bold', family: '"Times New Roman", "æ¥·ä½“", KaiTi, serif' }
                                    }
                                }
                            }
                        },
                        plugins: [emptyChartPlugin]
                    });

                    this.charts['main'] = chart;
                    return;
                }

                // å‡†å¤‡æ•°æ®
                const labels = this.data.map(d => d.æ—¥æœŸæ—¶é—´.toLocaleString('zh-CN'));
                
                // ä¸ºæ¯ä¸ªå‚æ•°åˆ›å»ºç‹¬ç«‹çš„Yè½´é…ç½®
                const scales = { 
                    x: {
                        title: { display: true, text: 'æ—¶é—´', font: { size: 19, family: '"Times New Roman", "æ¥·ä½“", KaiTi, serif' } },
                        ticks: { maxTicksLimit: 10, font: { size: 19, family: '"Times New Roman", "æ¥·ä½“", KaiTi, serif' } }
                    }
                };
                
                const datasets = parameters.map((param, index) => {
                    // æ£€æŸ¥æ˜¯å¦ä¸ºç¨€ç–é‡‡æ ·å‚æ•°
                    const sparseParams = ['ç¦»çº¿PH', 'ç”Ÿç‰©é‡', 'é…¶æ´»/(U/ml)', 'æ°¨åŸºæ°®å«é‡mg/L', 'è›‹ç™½å«é‡/(g/L)', 'ç”²é†‡å«é‡/%', 'è¿˜åŸç³–å«é‡/%', 'è‘¡è„ç³–å«é‡/%'];
                    
                    // æ£€æŸ¥æ˜¯å¦ä¸ºå‡ºæ–™è®°å½•å‚æ•°
                    const isOutputRecord = param.key === 'å‡ºæ–™è®°å½•' || param.label === 'å‡ºæ–™è®°å½•';
                    
                    // æ£€æŸ¥æ˜¯å¦ä¸ºå¤‡æ³¨å‚æ•°
                    const isRemarkRecord = param.key === 'å¤‡æ³¨' || param.label === 'å¤‡æ³¨';
                    
                    let values;
                    
                    if (sparseParams.includes(param.key)) {
                        // å¯¹äºç¨€ç–å‚æ•°ï¼Œä½¿ç”¨é¢„æµ‹æ•°æ®ï¼ˆåŒ…å«çœŸå®å€¼å’ŒAIé¢„æµ‹å€¼ï¼‰
                        values = this.data.map(d => d[`${param.key}_predicted`] || 0);
                    } else {
                        // å¯¹äºå¸¸è§„å‚æ•°ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹æ•°æ®
                        values = this.data.map(d => d[param.key] || 0);
                    }
                    
                    // ä¸ºå‡ºæ–™è®°å½•ç‰¹æ®Šå¤„ç†ï¼šåªä¿ç•™é0éç©ºçš„ç‚¹
                    if (isOutputRecord) {
                        values = this.data.map(d => {
                            const value = d[param.key];
                            // åªæœ‰é0ä¸”éç©ºçš„å€¼æ‰æ˜¾ç¤ºï¼Œå…¶ä»–è®¾ä¸ºnullï¼ˆä¸æ˜¾ç¤ºç‚¹ï¼‰
                            return (value !== null && value !== undefined && value !== 0 && value !== '') ? value : null;
                        });
                    }
                    
                    // ä¸ºå¤‡æ³¨è®°å½•ç‰¹æ®Šå¤„ç†ï¼šåªä¿ç•™éç©ºå­—ç¬¦ä¸²çš„ç‚¹ï¼Œç»Ÿä¸€è®¾ä¸º100æ˜¾ç¤º
                    if (isRemarkRecord) {
                        values = this.data.map(d => {
                            const value = d[param.key];
                            // åªæœ‰éç©ºå­—ç¬¦ä¸²æ‰æ˜¾ç¤ºï¼Œç»Ÿä¸€è®¾ä¸º100ï¼Œå…¶ä»–è®¾ä¸ºnullï¼ˆä¸æ˜¾ç¤ºç‚¹ï¼‰
                            return (value !== null && value !== undefined && value !== '' && typeof value === 'string') ? 100 : null;
                        });
                    }
                    
                    // ä¸ºæ¯ä¸ªæ•°æ®é›†åˆ›å»ºç‹¬ç«‹çš„Yè½´
                    const yAxisId = `y${index}`;
                    const isLeftSide = index % 2 === 0;
                    const axisPosition = isLeftSide ? 'left' : 'right';
                    
                    // è®¡ç®—æ•°æ®èŒƒå›´
                    const validValues = values.filter(v => v !== null && v !== undefined && !isNaN(v));
                    const minValue = validValues.length > 0 ? Math.min(...validValues) : 0;
                    const maxValue = validValues.length > 0 ? Math.max(...validValues) : 1;
                    const range = maxValue - minValue || 1;
                    const margin = range * 0.1;
                    
                    scales[yAxisId] = {
                        type: 'linear',
                        position: axisPosition,
                        title: {
                            display: true,
                            text: param.label,
                            color: param.color,
                            font: { weight: 'bold', size: 19, family: '"Times New Roman", "æ¥·ä½“", KaiTi, serif' }
                        },
                        min: minValue - margin,
                        max: maxValue + margin,
                        ticks: {
                            color: param.color,
                            font: { size: 19, weight: 'bold', family: '"Times New Roman", "æ¥·ä½“", KaiTi, serif' },
                            callback: function(value) { return (typeof value === 'number' && !isNaN(value) ? value : 0).toFixed(1); }
                        },
                        grid: {
                            drawOnChartArea: index === 0,
                            color: param.color + '20'
                        },
                        border: {
                            color: param.color,
                            width: 2
                        }
                    };
                    
                    // ä¸ºç¨€ç–å‚æ•°åˆ›å»ºå·®å¼‚åŒ–çš„ç‚¹æ ·å¼æ•°ç»„
                    let pointStyles, pointBackgrounds, pointBorders, pointRadiusArray, pointHoverRadiusArray;
                    
                    if (isOutputRecord) {
                        // å‡ºæ–™è®°å½•ç‰¹æ®Šå¤„ç†ï¼šè¾ƒå¤§çš„æ ‡è®°ç‚¹
                        pointStyles = 'circle';
                        pointBackgrounds = param.color;
                        pointBorders = param.color;
                        pointRadiusArray = 8; // å¢å¤§æ ‡è®°ç‚¹å¤§å°
                        pointHoverRadiusArray = 12; // å¢å¤§æ‚¬åœæ—¶çš„å¤§å°
                    } else if (isRemarkRecord) {
                        // å¤‡æ³¨è®°å½•ç‰¹æ®Šå¤„ç†ï¼šè¾ƒå¤§çš„æ ‡è®°ç‚¹
                        pointStyles = 'circle';
                        pointBackgrounds = param.color;
                        pointBorders = param.color;
                        pointRadiusArray = 7; // ä¸­ç­‰å¤§å°çš„æ ‡è®°ç‚¹
                        pointHoverRadiusArray = 11; // æ‚¬åœæ—¶çš„å¤§å°
                    } else if (sparseParams.includes(param.key)) {
                        // ä¸ºç¨€ç–å‚æ•°çš„æ¯ä¸ªæ•°æ®ç‚¹è®¾ç½®ä¸åŒæ ·å¼
                        pointStyles = this.data.map(record => {
                            const isPredicted = record[`${param.key}_isPredicted`];
                            return isPredicted ? 'circle' : 'circle'; // é¢„æµ‹å€¼å’Œå®æµ‹å€¼éƒ½ç”¨åœ†å½¢
                        });
                        
                        pointBackgrounds = this.data.map(record => {
                            const isPredicted = record[`${param.key}_isPredicted`];
                            return isPredicted ? 'white' : param.color; // é¢„æµ‹å€¼ç©ºå¿ƒç™½è‰²ï¼Œå®æµ‹å€¼å®å¿ƒ
                        });
                        
                        pointBorders = this.data.map(record => {
                            return param.color; // è¾¹æ¡†éƒ½ä½¿ç”¨å‚æ•°é¢œè‰²
                        });
                        
                        pointRadiusArray = this.data.map(record => {
                            const isPredicted = record[`${param.key}_isPredicted`];
                            return isPredicted ? 5 : 4; // é¢„æµ‹å€¼5ï¼ŒçœŸå®å€¼4
                        });
                        
                        pointHoverRadiusArray = this.data.map(record => {
                            const isPredicted = record[`${param.key}_isPredicted`];
                            return isPredicted ? 10 : 8; // é¢„æµ‹å€¼10ï¼ŒçœŸå®å€¼8
                        });
                    } else {
                        pointStyles = 'circle';
                        pointBackgrounds = param.color;
                        pointBorders = param.color;
                        pointRadiusArray = 3;
                        pointHoverRadiusArray = 6;
                    }
                    
                    return {
                        label: param.label,
                        data: values,
                        borderColor: (isOutputRecord || isRemarkRecord) ? 'transparent' : param.color, // å‡ºæ–™è®°å½•å’Œå¤‡æ³¨è®°å½•ä¸æ˜¾ç¤ºè¿çº¿
                        backgroundColor: param.color + '20',
                        fill: false,
                        tension: 0.5,
                        pointRadius: pointRadiusArray,
                        pointHoverRadius: pointHoverRadiusArray,
                        borderWidth: (isOutputRecord || isRemarkRecord) ? 0 : 2, // å‡ºæ–™è®°å½•å’Œå¤‡æ³¨è®°å½•ä¸æ˜¾ç¤ºè¿çº¿
                        yAxisID: yAxisId,
                        pointStyle: pointStyles,
                        pointBackgroundColor: pointBackgrounds,
                        pointHoverBackgroundColor: pointBackgrounds,
                        pointBorderColor: pointBorders,
                        pointBorderWidth: isOutputRecord ? 3 : (isRemarkRecord ? 2 : (sparseParams.includes(param.key) ? 2 : 1)), // è°ƒæ•´è¾¹æ¡†å®½åº¦
                        pointHoverBorderWidth: isOutputRecord ? 4 : (isRemarkRecord ? 3 : (sparseParams.includes(param.key) ? 2 : 1)),
                        showLine: !(isOutputRecord || isRemarkRecord), // å‡ºæ–™è®°å½•å’Œå¤‡æ³¨è®°å½•ä¸æ˜¾ç¤ºè¿çº¿
                        // ä¸ºç¨€ç–å‚æ•°æ·»åŠ æ ‡è¯†ï¼ˆä»…ç”¨äºå†…éƒ¨é€»è¾‘ï¼‰
                        sparseParam: sparseParams.includes(param.key),
                        // ä¸ºå‡ºæ–™è®°å½•æ·»åŠ æ ‡è¯†
                        outputRecord: isOutputRecord,
                        // ä¸ºå¤‡æ³¨è®°å½•æ·»åŠ æ ‡è¯†
                        remarkRecord: isRemarkRecord
                    };
                });

                // åå­—çº¿æ’ä»¶
                const crosshairPlugin = {
                    id: 'crosshair',
                    afterDatasetsDraw: function(chart) {
                        if (chart.tooltip._active && chart.tooltip._active.length) {
                            const ctx = chart.ctx;
                            const verticalLinePoint = chart.tooltip._active[0];
                            const x = verticalLinePoint.element.x;
                            const chartArea = chart.chartArea;
                            
                            ctx.save();
                            ctx.setLineDash([8, 4]);
                            ctx.strokeStyle = 'rgba(102, 126, 234, 0.7)';
                            ctx.lineWidth = 1.5;
                            ctx.beginPath();
                            ctx.moveTo(x, chartArea.top);
                            ctx.lineTo(x, chartArea.bottom);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                };

                // å‡†å¤‡æ’ä»¶é€‰é¡¹
                const pluginOptions = {};
                if (window.zoomPluginLoaded) {
                    pluginOptions.zoom = {
                        limits: { x: {min: 'original', max: 'original'} },
                        zoom: { wheel: { enabled: true, speed: 0.1 }, mode: 'x' }
                    };
                }

                // åˆ›å»ºå›¾è¡¨
                const chart = new Chart(ctx, {
                    type: 'line',
                    data: { labels, datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        onHover: (event, activeElements) => {
                            this.updateHoverDataPanel(activeElements, chart);
                        },
                        animation: { duration: 2000, easing: 'easeInOutQuart' },
                        plugins: {
                            ...pluginOptions,
                            legend: {
                                position: 'top',
                                align: 'center',
                                labels: {
                                    usePointStyle: true,
                                    padding: 20,
                                    boxWidth: 12,
                                    boxHeight: 12,
                                    font: { size: 19, family: '"Times New Roman", "æ¥·ä½“", KaiTi, serif' },
                                    generateLabels: function(chart) {
                                        const original = Chart.defaults.plugins.legend.labels.generateLabels;
                                        const labels = original.call(this, chart);
                                        
                                        labels.forEach((label, index) => {
                                            const dataset = chart.data.datasets[index];
                                            const values = dataset.data.filter(v => v !== null && v !== undefined && !isNaN(v));
                                            if (values.length > 0) {
                                                const min = Math.min(...values);
                                                const max = Math.max(...values);
                                                const minVal = typeof min === 'number' && !isNaN(min) ? min : 0;
                            const maxVal = typeof max === 'number' && !isNaN(max) ? max : 0;
                            label.text += ` [${minVal.toFixed(1)} - ${maxVal.toFixed(1)}]`;
                                            }
                                        });
                                        
                                        return labels;
                                    }
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                                titleColor: 'white',
                                bodyColor: 'white',
                                titleFont: { size: 17, weight: 'bold', family: '"Times New Roman", "æ¥·ä½“", KaiTi, serif' },
                                bodyFont: { size: 16, weight: 'bold', family: '"Times New Roman", "æ¥·ä½“", KaiTi, serif' },
                                callbacks: {
                                    title: function(context) {
                                        const index = context[0].dataIndex;
                                        const record = this.data[index];
                                        const dateTime = record.æ—¥æœŸæ—¶é—´;
                                        const dateStr = dateTime.toLocaleDateString('zh-CN');
                                        const timeStr = dateTime.toLocaleTimeString('zh-CN');
                                        return `${dateStr}\n${timeStr}\nå‘é…µç¬¬${(record.å‘é…µè®¡æ—¶ || 0).toFixed(1)}å°æ—¶`;
                                    }.bind(this),
                                    label: function(context) {
                                        const dataset = context.dataset;
                                        const value = context.parsed.y;
                                        const dataIndex = context.dataIndex;
                                        const paramKey = this.parameters.find(p => p.label === dataset.label)?.key;
                                        const record = this.data[dataIndex];
                                        const sparseParams = ['ç¦»çº¿PH', 'ç”Ÿç‰©é‡', 'é…¶æ´»/(U/ml)', 'æ°¨åŸºæ°®å«é‡mg/L', 'è›‹ç™½å«é‡/(g/L)', 'ç”²é†‡å«é‡/%', 'è¿˜åŸç³–å«é‡/%', 'è‘¡è„ç³–å«é‡/%'];
                                        
                                        let label = `${dataset.label}: ${(typeof value === 'number' && !isNaN(value) ? value : 0).toFixed(2)}`;
                                        
                                        // ä¸ºç¨€ç–å‚æ•°æ·»åŠ æ ‡è¯†
                        if (sparseParams.includes(paramKey)) {
                            const isPredicted = record[`${paramKey}_isPredicted`];
                            if (isPredicted) {
                                label += ' ğŸ¤–';
                            }
                        }
                        
                                                                // ä¸ºå‡ºæ–™è®°å½•æ·»åŠ ç‰¹æ®Šæ ‡è¯†
                        if (paramKey === 'å‡ºæ–™è®°å½•') {
                            label += ' ğŸ“¦';
                        }
                        
                        // ä¸ºå¤‡æ³¨è®°å½•æ·»åŠ ç‰¹æ®Šæ ‡è¯†ï¼Œå¹¶æ˜¾ç¤ºçœŸå®çš„å­—ç¬¦ä¸²å€¼
                        if (paramKey === 'å¤‡æ³¨') {
                            const remarkValue = record[paramKey];
                            if (remarkValue && typeof remarkValue === 'string') {
                                label = `${dataset.label}: ${remarkValue} ğŸ“`;
                            }
                        }
                                        
                                        return label;
                                    }.bind(this),
                                    labelTextColor: function(context) {
                                        const dataIndex = context.dataIndex;
                                        const paramKey = this.parameters.find(p => p.label === context.dataset.label)?.key;
                                        const record = this.data[dataIndex];
                                        const sparseParams = ['ç¦»çº¿PH', 'ç”Ÿç‰©é‡', 'é…¶æ´»/(U/ml)', 'æ°¨åŸºæ°®å«é‡mg/L', 'è›‹ç™½å«é‡/(g/L)', 'ç”²é†‡å«é‡/%', 'è¿˜åŸç³–å«é‡/%', 'è‘¡è„ç³–å«é‡/%'];
                                        
                                        if (sparseParams.includes(paramKey)) {
                            // ç¨€ç–å‚æ•°ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºé¢„æµ‹å€¼
                            const isPredicted = record[`${paramKey}_isPredicted`];
                            return isPredicted ? '#ff9800' : '#28a745'; // é¢„æµ‹å€¼æ©™è‰²ï¼Œå®æµ‹å€¼ç»¿è‰²
                        } else if (paramKey === 'å‡ºæ–™è®°å½•') {
                            // å‡ºæ–™è®°å½•ï¼šä½¿ç”¨çº¢è‰²
                            return '#FF0000';
                        } else if (paramKey === 'å¤‡æ³¨') {
                            // å¤‡æ³¨è®°å½•ï¼šä½¿ç”¨ç´«è‰²
                            return '#9b59b6';
                        } else {
                            // å¸¸è§„å‚æ•°ï¼šéƒ½æ˜¯å®æµ‹å€¼ï¼Œä½¿ç”¨ç»¿è‰²
                            return '#28a745';
                        }
                                    }.bind(this)
                                }
                            }
                        },
                        scales: scales
                    },
                    plugins: [crosshairPlugin]
                });

                this.charts['main'] = chart;
                
                // æ·»åŠ åŒå‡»é‡ç½®ç¼©æ”¾åŠŸèƒ½
                if (window.zoomPluginLoaded) {
                    canvas.addEventListener('dblclick', () => {
                        if (chart && chart.resetZoom) {
                            chart.resetZoom();
                        }
                    });
                }
            }

            updateHoverDataPanel(activeElements, chart) {
                const hoverDataGrid = document.getElementById('hoverDataGrid');
                const hoverTimeInfo = document.querySelector('.hover-time-info');
                
                if (!hoverDataGrid) return;
                
                if (activeElements.length === 0) {
                    // æ²¡æœ‰æ‚¬åœæ—¶ï¼Œæ˜¾ç¤ºå½“å‰æ—¶é—´å’Œé»˜è®¤æ•°æ®
                    if (hoverTimeInfo) {
                        const now = new Date();
                        hoverTimeInfo.innerHTML = `
                            <div class="hover-time">ğŸ“… ${now.toLocaleString('zh-CN')}</div>
                            <div class="hover-duration">å‘é…µç¬¬0.0å°æ—¶</div>
                        `;
                    }
                    
                    const dataItems = this.parameters.map(param => {
                        const isEnabled = param.enabled;
                        const sparseParams = ['ç¦»çº¿PH', 'ç”Ÿç‰©é‡', 'é…¶æ´»/(U/ml)', 'æ°¨åŸºæ°®å«é‡mg/L', 'è›‹ç™½å«é‡/(g/L)', 'ç”²é†‡å«é‡/%', 'è¿˜åŸç³–å«é‡/%', 'è‘¡è„ç³–å«é‡/%'];
                        
                        let displayValue = '0.00';
                        let valueType = '';
                        let valueColor = isEnabled ? param.color : '#999';
                        
                        if (this.data && this.data.length > 0) {
                            // è·å–æœ€æ–°æ•°æ®ç‚¹çš„å€¼
                            const latestRecord = this.data[this.data.length - 1];
                            
                            if (sparseParams.includes(param.key)) {
                        // ç¨€ç–å‚æ•°ï¼šä½¿ç”¨é¢„å¤„ç†çš„æ•°æ®
                        const predictedValue = latestRecord[`${param.key}_predicted`];
                        const isPredicted = latestRecord[`${param.key}_isPredicted`];
                        
                        if (predictedValue !== null && predictedValue !== undefined) {
                            displayValue = predictedValue.toFixed(2);
                            if (!isPredicted) {
                                valueType = ' (å®æµ‹)';
                                valueColor = param.color;
                            } else {
                                valueType = ' (AIé¢„æµ‹)';
                                valueColor = param.color;
                            }
                        }
                    } else if (param.key === 'å‡ºæ–™è®°å½•') {
                        // å‡ºæ–™è®°å½•ï¼šç‰¹æ®Šå¤„ç†
                        const outputValue = latestRecord[param.key];
                        if (outputValue !== null && outputValue !== undefined && outputValue !== 0 && outputValue !== '') {
                            displayValue = outputValue.toString();
                            valueType = ' (å‡ºæ–™)';
                            valueColor = param.color;
                        } else {
                            displayValue = 'æ— å‡ºæ–™';
                            valueType = '';
                            valueColor = '#999';
                        }
                    } else if (param.key === 'å¤‡æ³¨') {
                        // å¤‡æ³¨è®°å½•ï¼šç‰¹æ®Šå¤„ç†
                        const remarkValue = latestRecord[param.key];
                        if (remarkValue && typeof remarkValue === 'string' && remarkValue.trim() !== '') {
                            displayValue = remarkValue;
                            valueType = ' (å¤‡æ³¨)';
                            valueColor = param.color;
                        } else {
                            displayValue = 'æ— å¤‡æ³¨';
                            valueType = '';
                            valueColor = '#999';
                        }
                    } else {
                        // å¸¸è§„å‚æ•°ï¼šä½¿ç”¨åŸå§‹æ•°æ®
                        const realValue = latestRecord[param.key];
                        if (realValue !== null && realValue !== undefined && typeof realValue === 'number' && !isNaN(realValue)) {
                            displayValue = realValue.toFixed(2);
                            valueType = ' (å®æµ‹)';
                            valueColor = param.color;
                        }
                    }
                        }
                        
                        return `
                            <div class="hover-data-item ${isEnabled ? 'enabled' : 'disabled'}" style="border-left-color: ${param.color};">
                                <div class="hover-data-name" style="color: ${param.color}; font-weight: bold; font-size: 1.56rem; margin-bottom: 3px;">
                                    ${param.label}
                                </div>
                                <div class="hover-data-type" style="color: ${param.color}; font-size: 1.2rem; margin-bottom: 3px; opacity: 0.8; font-weight: bold;">
                                    ${valueType ? `(${valueType})` : ''}
                                </div>
                                <div class="hover-data-value" style="color: ${valueColor}; font-size: 1.56rem; font-weight: bold; font-family: 'Times New Roman', 'æ¥·ä½“', KaiTi, serif;">
                                    ${displayValue}
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    hoverDataGrid.innerHTML = `<div class="hover-data-items">${dataItems}</div>`;
                    return;
                }
                
                // è·å–æ‚¬åœç‚¹çš„ç´¢å¼•
                const dataIndex = activeElements[0].index;
                const record = this.data[dataIndex];
                
                if (!record) return;
                
                // æ›´æ–°æ—¶é—´ä¿¡æ¯
                if (hoverTimeInfo) {
                    hoverTimeInfo.innerHTML = `
                        <div class="hover-time">ğŸ“… ${record.æ—¥æœŸæ—¶é—´.toLocaleString('zh-CN')}</div>
                        <div class="hover-duration">å‘é…µç¬¬${(record.å‘é…µè®¡æ—¶ || 0).toFixed(1)}å°æ—¶</div>
                    `;
                }
                
                // åˆ›å»ºæ‰€æœ‰å‚æ•°çš„æ•°æ®ç½‘æ ¼
                const dataItems = this.parameters.map(param => {
                    const isEnabled = param.enabled;
                    const sparseParams = ['ç¦»çº¿PH', 'ç”Ÿç‰©é‡', 'é…¶æ´»/(U/ml)', 'æ°¨åŸºæ°®å«é‡mg/L', 'è›‹ç™½å«é‡/(g/L)', 'ç”²é†‡å«é‡/%', 'è¿˜åŸç³–å«é‡/%', 'è‘¡è„ç³–å«é‡/%'];
                    
                    let displayValue, valueType, valueColor;
                    
                    // æ£€æŸ¥æ˜¯å¦ä¸ºç¨€ç–é‡‡æ ·å‚æ•°
                    if (sparseParams.includes(param.key)) {
                        // ç¨€ç–å‚æ•°ï¼šä»é¢„å¤„ç†æ•°æ®ä¸­è·å–å€¼
                        const predictedValue = record[`${param.key}_predicted`];
                        const isPredicted = record[`${param.key}_isPredicted`];
                        
                        if (predictedValue !== null && predictedValue !== undefined) {
                            displayValue = predictedValue.toFixed(2);
                            
                            if (!isPredicted) {
                                // çœŸå®æµ‹é‡å€¼
                                valueType = 'å®æµ‹å€¼';
                                valueColor = param.color;
                            } else {
                                // AIé¢„æµ‹å€¼
                                valueType = 'AIé¢„æµ‹å€¼';
                                valueColor = param.color;
                            }
                        } else {
                            displayValue = 'æ— æ•°æ®';
                            valueType = '';
                            valueColor = '#999';
                        }
                    } else if (param.key === 'å‡ºæ–™è®°å½•') {
                        // å‡ºæ–™è®°å½•ï¼šç‰¹æ®Šå¤„ç†
                        const outputValue = record[param.key];
                        if (outputValue !== null && outputValue !== undefined && outputValue !== 0 && outputValue !== '') {
                            displayValue = outputValue.toString();
                            valueType = 'å‡ºæ–™è®°å½•';
                            valueColor = param.color;
                        } else {
                            displayValue = 'æ— å‡ºæ–™';
                            valueType = '';
                            valueColor = '#999';
                        }
                    } else if (param.key === 'å¤‡æ³¨') {
                        // å¤‡æ³¨è®°å½•ï¼šç‰¹æ®Šå¤„ç†
                        const remarkValue = record[param.key];
                        if (remarkValue && typeof remarkValue === 'string' && remarkValue.trim() !== '') {
                            displayValue = remarkValue;
                            valueType = 'å¤‡æ³¨ä¿¡æ¯';
                            valueColor = param.color;
                        } else {
                            displayValue = 'æ— å¤‡æ³¨';
                            valueType = '';
                            valueColor = '#999';
                        }
                    } else {
                        // å¸¸è§„å‚æ•°ï¼šç›´æ¥ä½¿ç”¨åŸå§‹æ•°æ®
                        const realValue = record[param.key];
                        if (realValue !== null && realValue !== undefined && typeof realValue === 'number' && !isNaN(realValue)) {
                            displayValue = realValue.toFixed(2);
                            valueType = 'å®æµ‹å€¼';
                            valueColor = param.color;
                        } else {
                            displayValue = 'æ— æ•°æ®';
                            valueType = '';
                            valueColor = '#999';
                        }
                    }
                    
                    return `
                        <div class="hover-data-item ${isEnabled ? 'enabled' : 'disabled'}" style="border-left-color: ${param.color};">
                            <div class="hover-data-name" style="color: ${param.color}; font-weight: bold; font-size: 1.56rem; margin-bottom: 3px;">
                                ${param.label}
                            </div>
                            <div class="hover-data-type" style="color: ${param.color}; font-size: 1.2rem; margin-bottom: 3px; opacity: 0.8; font-weight: bold;">
                                ${valueType ? `(${valueType})` : ''}
                            </div>
                            <div class="hover-data-value" style="color: ${valueColor}; font-size: 1.56rem; font-weight: bold; font-family: 'Times New Roman', 'æ¥·ä½“', KaiTi, serif;">
                                ${displayValue}
                            </div>
                        </div>
                    `;
                }).join('');
                
                hoverDataGrid.innerHTML = `<div class="hover-data-items">${dataItems}</div>`;
            }

            // ä¸ºç¨€ç–é‡‡æ ·æ•°æ®é¢„å¤„ç†å®Œæ•´çš„æ•°æ®é›†
            preprocessSparseData() {
                const sparseParams = ['ç¦»çº¿PH', 'ç”Ÿç‰©é‡', 'é…¶æ´»/(U/ml)', 'æ°¨åŸºæ°®å«é‡mg/L', 'è›‹ç™½å«é‡/(g/L)', 'ç”²é†‡å«é‡/%', 'è¿˜åŸç³–å«é‡/%', 'è‘¡è„ç³–å«é‡/%'];
                
                console.log('å¼€å§‹ç¨€ç–æ•°æ®é¢„å¤„ç†ï¼Œå‚æ•°åˆ—è¡¨:', sparseParams);
                
                // ä¸ºæ¯ä¸ªç¨€ç–å‚æ•°åˆ›å»ºå®Œæ•´çš„é¢„æµ‹æ•°æ®
                sparseParams.forEach(paramKey => {
                    this.createCompleteDataset(paramKey);
                });
            }

            // è°ƒè¯•é¢„å¤„ç†ç»“æœ
            debugPreprocessingResults() {
                const sparseParams = ['ç¦»çº¿PH', 'ç”Ÿç‰©é‡', 'é…¶æ´»/(U/ml)', 'æ°¨åŸºæ°®å«é‡mg/L', 'è›‹ç™½å«é‡/(g/L)', 'ç”²é†‡å«é‡/%', 'è¿˜åŸç³–å«é‡/%', 'è‘¡è„ç³–å«é‡/%'];
                
                console.log('=== ç¨€ç–æ•°æ®é¢„å¤„ç†ç»“æœæ£€æŸ¥ ===');
                
                sparseParams.forEach(paramKey => {
                    const realCount = this.data.filter(record => record[paramKey] && record[paramKey] > 0).length;
                    const predictedCount = this.data.filter(record => record[`${paramKey}_isPredicted`] === true).length;
                    const totalCount = this.data.length;
                    
                    console.log(`${paramKey}:`);
                    console.log(`  æ€»æ•°æ®ç‚¹: ${totalCount}`);
                    console.log(`  çœŸå®æµ‹é‡ç‚¹: ${realCount}`);
                    console.log(`  AIé¢„æµ‹ç‚¹: ${predictedCount}`);
                    console.log(`  è¦†ç›–ç‡: ${((realCount + predictedCount) / totalCount * 100).toFixed(1)}%`);
                    
                    // æ˜¾ç¤ºå‰å‡ ä¸ªé¢„æµ‹å€¼æ ·ä¾‹
                    const samples = this.data.slice(0, 5).map(record => ({
                        time: record.å‘é…µè®¡æ—¶,
                        original: record[paramKey],
                        predicted: record[`${paramKey}_predicted`],
                        isPredicted: record[`${paramKey}_isPredicted`]
                    }));
                    console.log(`  å‰5ä¸ªæ•°æ®ç‚¹æ ·ä¾‹:`, samples);
                });
                
                console.log('=== é¢„å¤„ç†ç»“æœæ£€æŸ¥å®Œæˆ ===');
                
                // æ£€æŸ¥å¤‡æ³¨æ•°æ®
                const remarkCount = this.data.filter(record => record['å¤‡æ³¨'] && typeof record['å¤‡æ³¨'] === 'string' && record['å¤‡æ³¨'].trim() !== '').length;
                console.log(`å¤‡æ³¨ä¿¡æ¯ç»Ÿè®¡:`);
                console.log(`  æ€»æ•°æ®ç‚¹: ${this.data.length}`);
                console.log(`  æœ‰å¤‡æ³¨çš„ç‚¹: ${remarkCount}`);
                
                if (remarkCount > 0) {
                    const remarkSamples = this.data.filter(record => record['å¤‡æ³¨'] && typeof record['å¤‡æ³¨'] === 'string' && record['å¤‡æ³¨'].trim() !== '').slice(0, 3);
                    console.log(`  å¤‡æ³¨æ ·ä¾‹:`, remarkSamples.map(r => ({ time: r.å‘é…µè®¡æ—¶, remark: r['å¤‡æ³¨'] })));
                }
            }

            // ä¸ºå•ä¸ªç¨€ç–å‚æ•°åˆ›å»ºå®Œæ•´æ•°æ®é›†
            createCompleteDataset(paramKey) {
                // è·å–æ‰€æœ‰çœŸå®æµ‹é‡å€¼ï¼ˆéé›¶å€¼ä¸”éç©ºå€¼ï¼‰
                const realValues = [];
                this.data.forEach((record, index) => {
                    const value = record[paramKey];
                    if (value && value > 0) {
                        realValues.push({
                            index: index,
                            value: value,
                            time: record.å‘é…µè®¡æ—¶ || 0
                        });
                    }
                });

                console.log(`${paramKey} æ‰¾åˆ° ${realValues.length} ä¸ªçœŸå®æµ‹é‡å€¼:`, realValues);

                if (realValues.length === 0) {
                    // æ²¡æœ‰çœŸå®å€¼ï¼Œæ‰€æœ‰ç‚¹éƒ½è®¾ä¸º0
                    this.data.forEach((record, index) => {
                        record[`${paramKey}_predicted`] = 0;
                        record[`${paramKey}_isPredicted`] = false;
                    });
                    return;
                }

                if (realValues.length === 1) {
                    // åªæœ‰ä¸€ä¸ªçœŸå®å€¼ï¼Œç”¨å®ƒå¡«å……æ‰€æœ‰ç¼ºå¤±ç‚¹
                    const singleValue = realValues[0].value;
                    this.data.forEach((record, index) => {
                        if (!record[paramKey] || record[paramKey] <= 0) {
                            record[`${paramKey}_predicted`] = singleValue;
                            record[`${paramKey}_isPredicted`] = true;
                        } else {
                            record[`${paramKey}_predicted`] = record[paramKey];
                            record[`${paramKey}_isPredicted`] = false;
                        }
                    });
                    return;
                }

                // ä½¿ç”¨æ ·æ¡æ’å€¼æˆ–çº¿æ€§æ’å€¼è¿›è¡Œé¢„æµ‹
                this.data.forEach((record, index) => {
                    if (!record[paramKey] || record[paramKey] <= 0) {
                        // è¿™æ˜¯ç¼ºå¤±ç‚¹ï¼Œéœ€è¦é¢„æµ‹
                        const predicted = this.interpolateValue(paramKey, index, realValues);
                        record[`${paramKey}_predicted`] = predicted ? predicted.value : 0;
                        record[`${paramKey}_isPredicted`] = predicted ? true : false;
                        record[`${paramKey}_predictionType`] = predicted ? predicted.type : 'none';
                        record[`${paramKey}_predictionInfo`] = predicted ? predicted.info : null;
                    } else {
                        // çœŸå®æµ‹é‡å€¼
                        record[`${paramKey}_predicted`] = record[paramKey];
                        record[`${paramKey}_isPredicted`] = false;
                    }
                });
            }

            // æ”¹è¿›çš„æ’å€¼ç®—æ³•
            interpolateValue(paramKey, targetIndex, realValues = null) {
                const sparseParams = ['ç¦»çº¿PH', 'ç”Ÿç‰©é‡', 'é…¶æ´»/(U/ml)', 'æ°¨åŸºæ°®å«é‡mg/L', 'è›‹ç™½å«é‡/(g/L)', 'ç”²é†‡å«é‡/%', 'è¿˜åŸç³–å«é‡/%', 'è‘¡è„ç³–å«é‡/%'];
                if (!sparseParams.includes(paramKey)) {
                    return null;
                }

                // å¦‚æœæ²¡æœ‰æä¾›realValuesï¼Œé‡æ–°è·å–
                if (!realValues) {
                    realValues = [];
                    this.data.forEach((record, index) => {
                        const value = record[paramKey];
                        if (value && value > 0) {
                            realValues.push({
                                index: index,
                                value: value,
                                time: record.å‘é…µè®¡æ—¶ || 0
                            });
                        }
                    });
                }

                if (realValues.length < 2) {
                    return null;
                }

                const targetTime = this.data[targetIndex].å‘é…µè®¡æ—¶;

                // æ‰¾åˆ°ç›®æ ‡æ—¶é—´ç‚¹å·¦å³çš„çœŸå®æµ‹é‡ç‚¹
                let leftPoint = null;
                let rightPoint = null;

                for (let i = 0; i < realValues.length; i++) {
                    if (realValues[i].index <= targetIndex) {
                        leftPoint = realValues[i];
                    }
                    if (realValues[i].index > targetIndex && !rightPoint) {
                        rightPoint = realValues[i];
                        break;
                    }
                }

                // å¦‚æœç›®æ ‡ç‚¹å°±æ˜¯çœŸå®æµ‹é‡ç‚¹ï¼Œè¿”å›nullï¼ˆä½¿ç”¨çœŸå®å€¼ï¼‰
                if (leftPoint && leftPoint.index === targetIndex) {
                    return null;
                }

                // è¿›è¡Œæ”¹è¿›çš„æ’å€¼
                if (leftPoint && rightPoint) {
                    // åŒè¾¹æ’å€¼ - ä½¿ç”¨æ”¹è¿›çš„ç®—æ³•
                    const timeDiff = rightPoint.time - leftPoint.time;
                    const targetTimeDiff = targetTime - leftPoint.time;
                    const ratio = targetTimeDiff / timeDiff;
                    
                    // è€ƒè™‘æ›´å¤šé‚»è¿‘ç‚¹è¿›è¡Œæ›´å¹³æ»‘çš„æ’å€¼
                    let interpolatedValue = leftPoint.value + (rightPoint.value - leftPoint.value) * ratio;
                    
                    // å¦‚æœæœ‰æ›´å¤šæ•°æ®ç‚¹ï¼Œä½¿ç”¨åŠ æƒå¹³å‡æ”¹å–„æ’å€¼
                    const nearbyPoints = realValues.filter(p => 
                        Math.abs(p.time - targetTime) <= Math.abs(timeDiff) * 1.5
                    );
                    
                    if (nearbyPoints.length > 2) {
                        // ä½¿ç”¨è·ç¦»åŠ æƒå¹³å‡
                        let weightedSum = 0;
                        let totalWeight = 0;
                        
                        nearbyPoints.forEach(point => {
                            const distance = Math.abs(point.time - targetTime);
                            const weight = 1 / (distance + 0.1); // é¿å…é™¤é›¶
                            weightedSum += point.value * weight;
                            totalWeight += weight;
                        });
                        
                        const weightedAverage = weightedSum / totalWeight;
                        // æ··åˆçº¿æ€§æ’å€¼å’ŒåŠ æƒå¹³å‡
                        interpolatedValue = interpolatedValue * 0.7 + weightedAverage * 0.3;
                    }
                    
                    return {
                        value: Math.max(0, interpolatedValue), // ç¡®ä¿éè´Ÿå€¼
                        type: 'interpolated',
                        leftPoint: leftPoint,
                        rightPoint: rightPoint,
                        info: `åŸºäºç¬¬${leftPoint.time.toFixed(1)}h-${rightPoint.time.toFixed(1)}hçš„AIæ’å€¼é¢„æµ‹`
                    };
                } else if (leftPoint) {
                    // åªæœ‰å·¦è¾¹ç‚¹ï¼Œä½¿ç”¨è¶‹åŠ¿å¤–æ¨
                    let extrapolatedValue = leftPoint.value;
                    
                    // å¦‚æœæœ‰è¶³å¤Ÿçš„å†å²æ•°æ®ï¼Œè®¡ç®—è¶‹åŠ¿
                    if (realValues.length >= 2) {
                        const recentPoints = realValues.slice(-Math.min(3, realValues.length));
                        if (recentPoints.length >= 2) {
                            // è®¡ç®—å¹³å‡å˜åŒ–ç‡
                            let totalChange = 0;
                            for (let i = 1; i < recentPoints.length; i++) {
                                const timeDiff = recentPoints[i].time - recentPoints[i-1].time;
                                const valueDiff = recentPoints[i].value - recentPoints[i-1].value;
                                totalChange += valueDiff / timeDiff;
                            }
                            const avgChangeRate = totalChange / (recentPoints.length - 1);
                            
                            // åŸºäºè¶‹åŠ¿å¤–æ¨
                            const extrapolationTime = targetTime - leftPoint.time;
                            extrapolatedValue = leftPoint.value + avgChangeRate * extrapolationTime;
                        }
                    }
                    
                    return {
                        value: Math.max(0, extrapolatedValue),
                        type: 'extrapolated_left',
                        leftPoint: leftPoint,
                        info: `åŸºäºç¬¬${leftPoint.time.toFixed(1)}hçš„AIè¶‹åŠ¿å¤–æ¨`
                    };
                } else if (rightPoint) {
                    // åªæœ‰å³è¾¹ç‚¹ï¼Œå‘å‰å¤–æ¨
                    let extrapolatedValue = rightPoint.value;
                    
                    // å¦‚æœæœ‰è¶³å¤Ÿçš„æœªæ¥æ•°æ®ï¼Œè®¡ç®—è¶‹åŠ¿
                    if (realValues.length >= 2) {
                        const futurePoints = realValues.slice(0, Math.min(3, realValues.length));
                        if (futurePoints.length >= 2) {
                            // è®¡ç®—å¹³å‡å˜åŒ–ç‡
                            let totalChange = 0;
                            for (let i = 1; i < futurePoints.length; i++) {
                                const timeDiff = futurePoints[i].time - futurePoints[i-1].time;
                                const valueDiff = futurePoints[i].value - futurePoints[i-1].value;
                                totalChange += valueDiff / timeDiff;
                            }
                            const avgChangeRate = totalChange / (futurePoints.length - 1);
                            
                            // åŸºäºè¶‹åŠ¿å¤–æ¨
                            const extrapolationTime = rightPoint.time - targetTime;
                            extrapolatedValue = rightPoint.value - avgChangeRate * extrapolationTime;
                        }
                    }
                    
                    return {
                        value: Math.max(0, extrapolatedValue),
                        type: 'extrapolated_right',
                        rightPoint: rightPoint,
                        info: `åŸºäºç¬¬${rightPoint.time.toFixed(1)}hçš„AIè¶‹åŠ¿å¤–æ¨`
                    };
                }

                return null;
            }

            showError(message) {
                const fileInfo = document.getElementById('fileInfo');
                fileInfo.style.display = 'block';
                fileInfo.innerHTML = `<div class="error">âŒ ${message}</div>`;
            }
        }

        // æ£€æŸ¥ä¾èµ–åº“æ˜¯å¦åŠ è½½æˆåŠŸ
        function checkDependencies() {
            return new Promise((resolve) => {
                let retryCount = 0;
                const maxRetries = 20;
                
                function checkLibraries() {
                    if (typeof Chart === 'undefined') {
                        if (window.chartJsLoadFailed) {
                            console.log('Chart.js åŠ è½½å¤±è´¥');
                            showChartLoadError();
                            resolve(false);
                            return;
                        }
                        
                        retryCount++;
                        if (retryCount < maxRetries) {
                            console.log(`æ£€æŸ¥Chart.jsåŠ è½½çŠ¶æ€... (${retryCount}/${maxRetries})`);
                            setTimeout(checkLibraries, 500);
                        } else {
                            console.log('Chart.js åŠ è½½è¶…æ—¶');
                            showChartLoadError();
                            resolve(false);
                        }
                        return;
                    }
                    
                    if (window.zoomPluginLoaded === false && window.chartJsLoaded) {
                        console.log('Chart.jsåŠ è½½æˆåŠŸï¼Œzoomæ’ä»¶åŠ è½½å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨åŸºç¡€åŠŸèƒ½');
                        resolve(true);
                        return;
                    }
                    
                    if (window.zoomPluginLoaded) {
                        console.log('Chart.jså’Œzoomæ’ä»¶éƒ½åŠ è½½æˆåŠŸ');
                        resolve(true);
                        return;
                    }
                    
                    retryCount++;
                    if (retryCount < maxRetries) {
                        console.log(`ç­‰å¾…æ’ä»¶åŠ è½½å®Œæˆ... (${retryCount}/${maxRetries})`);
                        setTimeout(checkLibraries, 500);
                    } else {
                        console.log('ç­‰å¾…æ’ä»¶åŠ è½½è¶…æ—¶ï¼Œä½¿ç”¨åŸºç¡€åŠŸèƒ½');
                        resolve(true);
                    }
                }
                
                checkLibraries();
            });
        }
        
        function showChartLoadError() {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.innerHTML = `
                <h4>âš ï¸ åœ¨çº¿å›¾è¡¨åº“æ— æ³•åŠ è½½</h4>
                <p><strong>å»ºè®®è§£å†³æ–¹æ¡ˆï¼š</strong></p>
                <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 15px; margin: 15px 0;">
                    <h5 style="color: #856404; margin-bottom: 10px;">ğŸ”„ ç½‘ç»œè¿æ¥é—®é¢˜</h5>
                    <p style="color: #856404; margin-bottom: 10px;">å›¾è¡¨åº“åŠ è½½å¤±è´¥ï¼Œè¯·å°è¯•é‡æ–°åŠ è½½æˆ–æ£€æŸ¥ç½‘ç»œè¿æ¥ï¼š</p>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                        <button onclick="retryChartLoad()" 
                                style="background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; min-width: 200px;">
                            ğŸ”„ é‡æ–°å°è¯•åŠ è½½
                        </button>
                    </div>
                </div>
            `;
            document.querySelector('.container').appendChild(errorDiv);
        }

        // å…¨é€‰/å–æ¶ˆå…¨é€‰åŠŸèƒ½
        function selectAllParameters() {
            const viewer = window.excelViewer;
            if (viewer) {
                viewer.parameters.forEach((param, index) => {
                    param.enabled = true;
                    const checkbox = document.getElementById(`param_${index}`);
                    if (checkbox) checkbox.checked = true;
                });
                viewer.updateCharts();
            }
        }
        
        function unselectAllParameters() {
            const viewer = window.excelViewer;
            if (viewer) {
                viewer.parameters.forEach((param, index) => {
                    param.enabled = false;
                    const checkbox = document.getElementById(`param_${index}`);
                    if (checkbox) checkbox.checked = false;
                });
                viewer.updateCharts();
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', async () => {
            const loadingIndicator = document.getElementById('loadingIndicator');
            
            try {
                const chartLoaded = await checkDependencies();
                if (chartLoaded) {
                    // è®¾ç½®Chart.jså…¨å±€å­—ä½“
                    if (typeof Chart !== 'undefined') {
                        Chart.defaults.font.family = '"Times New Roman", "æ¥·ä½“", KaiTi, serif';
                        Chart.defaults.font.weight = 'bold';
                    }
                    
                    console.log('å¼€å§‹åˆå§‹åŒ–Excelæ•°æ®æŸ¥çœ‹å™¨...');
                    window.excelViewer = new ExcelDataViewer();
                    console.log('Excelæ•°æ®æŸ¥çœ‹å™¨åˆå§‹åŒ–å®Œæˆ');
                }
            } catch (error) {
                console.error('åˆå§‹åŒ–è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error);
                showChartLoadError();
            } finally {
                // éšè—åŠ è½½æŒ‡ç¤ºå™¨
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                }
            }
        });
    </script>
</body>
</html>